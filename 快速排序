
快速排序

72	6	57	88	60	42	83	73	48	86

算法核心思想

1.定义一个基准数，也就是相当于参照物，毕竟，没有对比就没有伤害嘛，
一般取这个数组的第一个元素作为基准数，你也可以不选它，这是习惯嘛，所以选了第一个作为基准数。

2.分别从前往后和从后往前取数和基准数做比较，把比基准数大的放在右边，把比基准数小的放在左边。

3.达到的目的就是，基准数在中间位置，基准数左边的数都比它小，基准数右边的数据都比它大，
这样排出了一定的顺序，即左边大，右边小，是不是想到上学跑操站队了。

4.基准数把整个数组的数据分为了两组，左边部分是一组，右边部分是另一组，再分别在两组数据中分别重复上述过程比较。

具体操作

i(i从左往右开始走)  ->					<-  j(j从右往左开始走)
0	1	2	3	4	5	6	7	8	9

72	6	57	88	60	42	83	73	48	86

i = 0	j = 9	X = 72(把基准数72放在一个盒子X里面存放起来,只要不动盒子，这个数一直在，只要保存起来不清空，那么它与数组中的数就没有关系了)

第一次，j = 9往左开始找，找不到继续往左(即j--),直到找到比基准数72小的数就暂时停止(找到就暂时停止，给i一个机会嘛，别自己一个人玩,
这也是快速排序的思想，快需要合作，个人理解，不要在意哈)，此时j = 8

这里找到 j = 8 的时候，a[0] = a[8]  即把 48放到 a[0] 此时，可以理解为a[8]这个地方是空的，可以放数据了，找到了比72小的了，
也交换到前面去了，j先等着，给i机会
i									j		
0	1	2	3	4	5	6	7	8	9

48	6	57	88	60	42	83	73	48	86
(48还在，因为只是相当于把值赋值到了别的地方，自己没有清除，为了好理解可以视为空，因为可以随时赋值了，可以理解为已经是没用的数据了）
0	1	2	3	4	5	6	7	8	9
48	6	57	88	60	42	83	73		86
i = 0,j = 8

然后i 上场，从左往右开始找，找不到就继续往后(即i++)，直到找到比基准数72大的，放在刚才j让出的位置的地方

这里找到 i = 3 的时候找到88比基准数大，a[8] = a [3],即把88放在a[8]的位置，此时，可以理解为a[3]这个位置为空了，可以放数据了。此时i = 3,然后i先停止，给j一个机会。

0	1	2	3	4	5	6	7	8	9
48	6	57		60	42	83	73	88	86
i = 3,j = 8

到j上场了，之前j = 8开始，j继续往前(j--),开始找比基准数72小的数，一直找到了j = 5的位置，找到了42比基准数72小，放在刚才i = 3的位置，即a[3] = a[5],
同理可以理解为a[5]为空了，可以存放数据，此时j = 5,然后j暂时停止,给i一个机会。

0	1	2	3	4	5	6	7	8	9
48	6	57	42	60		83	73	88	86
i = 3,j = 5

又到i上场了，之前i = 3，现在继续往右推进(i++),找一个比基准数大的数就停止，这里一直找到i = 5也没找到比基准数72大的数，
此时i此时i= j,两人终于见面了，哈，遇到了哇,i和j好好聊聊？喝咖啡去？免了，干完工作赶紧下班呢，来咱两相互汇报一下工作情况。
j给i说我把比基准数小的都放前面去了，i告诉j我把比基准数大的都放后面去了。要不咱先这样吧？改天再约，
然后，i和j下班回家了，X来了，基准数来到他们相遇的地方拭擦工作，干脆住下了，即a[5] = X,即为a[i] = X 或者 a[j] = X

0	1	2	3	4	5	6	7	8	9
48	6	57	42	60	X	83	73	88	86
i = 5,j = 5
X = 72

所以第一趟排序结果如下：
0	1	2	3	4	5	6	7	8	9
48	6	57	42	60	72	83	73	88	86
i = 5,j = 5
X = 72

此时，观察基准数72左右两边的数，即 72左边的数都比72小，72右边的数都比72大，
得到了一个较好的排序，又想到了战队，高的，你站哪儿呢，往后去，哎哎，那个矮的，注意你位置啊~

然后开始下一轮

下一轮就更好玩了，把基准数72左边的分为一组，即0~4为一组，基准数72右边的分为另一组，即6~9为另一组，开始重复上述步骤。

直到统一都是由小到大这种规则，就排序出来了。
如左边0~4部分的排序
0	1	2	3	4
48	6	57	42	60
i = 0,j = 4
X = 48

0	1	2	3	4
42	6	57		60
i = 0,j = 3

0	1	2	3	4
42	6		57	60
i = 2,j = 3

0	1	2	3	4
42	6		57	60
i = 2,j = 2 j = j 停止
X = 48

0	1	2	3	4
42	6	48	57	60
i = 2,j = 2 j = j 停止
X = 48

48左边 0~1,右边3~4分为两组

左边
0	1
42	6
i = 0，j = 1
X = 42

42作为基准数

0	1
6	
i = 0，j = 0
X = 42

0	1
6	42
i = 0，j = 0
X = 42

依次类推，最终就能排位整齐的一队。

 代码实现如下
 
 private void quicklySort(int[] arr, int l, int r) {
        if (l < r) {    //方便递归调用
            int i = l, j = r, X = arr[l];//用X盒子来装基准数（作为参照物）
            while (i < j) {
                while (i < j && arr[j] > X) {//j从右往左开始循环，如果右边的数都大于基准数
                    j--;  //则继续往左
                }
                if (i < j) {  //否则 右边找到有数小于等于基准数，把这个数赋值给arr[i],即基准数原来所在的位置
                    arr[i] = arr[j];
                    i++;//让出机会，让i开始循环
                }
                while (i < j && arr[i] < X) {//i从左往右开始循环，如果左边的数都小于基准数
                    i++;//则继续往右
                }
                if (i < j) {//否则 左边的找到有数大于等于基准数，把找到的值赋值给j刚才让出来的位置
                    arr[j] = arr[i];
                    j--;//让出机会，让j开始循环
                }
            }
            arr[i] = X;//如果i不小于j说明此时i,j 已经相遇，值已经相等，这时候把基准数赋值给i或j所在的位置
            //到此已经排好第一轮，数据排序情况为 基准数左边的数都小于基准数，基准数右边的数都大于基准数
            //下面开始递归调用，把基准数左右两边的数分别递归调用获取得到新一轮的进一步排序，左边和右边的里面的数也是基准数左边的数比基准数小，右边的数比基准数右边大
            quicklySort(arr, l, i - 1);//基准数左边部分
            quicklySort(arr, i + 1, r);//基准数右边部分
        }
        
        
        时间复杂度为O(n^2)

