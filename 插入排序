	
  算法思想：
  把一个数组分为两段，前一段是有序的，后一段是无序的
  
  即 整体序列 = 有序序列 + 无序序列
  
  也就是把数组一分为二，左边有序，右边无序
  
  然后拿着无序列表里面的元素和有序列表的数逐一比较，而且是从右往左比较，这里默认有序序列的数组是从小到大排列的
  
  所以拿着无序序列里面的第一个元素开始和有序序列里面的最后一个元素开始往前比较，
  
  如果这个无序的数在有序序列里面比最后一个元素大，说明，它就是有序序列里面最大的，直接放在有序序列的后面即可，
  
  如果不大于最后一个，继续往前比较，如果大于前面的某个数，就放在那个数的后面即可，否则继续，直到比较到有序的最前面，
  
  说明是最小的，直接放在最前面即可
  
  这里刚开始并不知道怎么区分有序和无序，也不用写算法判断，直接把第一个元素默认为有序序列的元素
  
  即 整体序列 = 有序序列（第一次没有有序的，直接默认第一个元素为有序的序列，这个序列中目前只有一个元素，那就是整体序列的第一个元素，
  
  一个数当然是有序的，自己和自己比，怎么都是有序的） + 无序序列（因为后面的数可能排列规则是随机的，也不用关心是否有序，默认无序）
  
  然后开始比较，拿着无序序列里面的元素和有序序列列里面的元素做比较
  
  实现代码如下：
  
  private static void insertSort(int[] arr) {
	   int arrSize = arr.length;//提高效率，避免在for循环中每次都计算arr.length
	   for(int i = 1;i < arrSize; i++){
	      int temp = arr[i];//把第i个无序的需要交换的元素存放起来
          int j = i;
	      while(j > 0 && temp < arr[j-1]) {//判断是否已经到达数组的最前面并且判断需要
                                	      //交换的元素是否小于第arr[j-1]元素，即从右往左开始比较，比较前一个数是否小于需要
                                	      //交换的元素，如果小于，j --,并且所有元素往后移动一位
	          arr[j] = arr[j -1];//如果需要交换的数小于前面有序的元素，把与之比较的有序的元素赋值给刚才j的位置，j-1的元素值还是不变，
		  //但是他后面的元素的值已经被赋值为它了，继续往前循环。
	          j --;
	      }
	      arr[j] = temp;//如果需要插入的元素大于或等于前一个元素，即 temp >= arr[j+1] 
	      //那么，说明需要插入的数在有序里面是最大的，直接放在有序的后面即可，即arr[j] = temp
	   }
	}
	
 时间复杂度为O(n^2)
